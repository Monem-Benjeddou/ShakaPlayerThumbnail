<div id="video-container" class="video-container">
  <video id="video" controls></video>
  <div id="seekbar-container">
    <div id="seek-bar"></div>
    <div id="thumb" class="thumbnail"></div>
  </div>
  <button id="fullscreen-toggle-btn"></button>
  <div id="error" class="error-message"></div>
</div>

<script>
  document.addEventListener('DOMContentLoaded', async () => {
    const fullscreenToggleBtn = document.getElementById('fullscreen-toggle-btn');
    const video = document.getElementById('video');
    const seekBar = document.getElementById('seek-bar');
    const thumbElement = document.getElementById('thumb');
    const errorDisplay = document.getElementById('error');
    const videoContainer = document.getElementById('video-container');
    const player = new shaka.Player(video);
    let lastPreviewPosition, isPlayingPreview = false, hideThumbnailTimer, thumbnailTrack, isHovering = false; 

    // Fullscreen toggle logic
    fullscreenToggleBtn?.addEventListener('click', toggleFullscreen);

    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        videoContainer.requestFullscreen?.() ||
        videoContainer.mozRequestFullScreen?.() ||
        videoContainer.webkitRequestFullscreen?.() ||
        videoContainer.msRequestFullscreen?.();
      } else {
        document.exitFullscreen?.();
      }
    }

    document.addEventListener('fullscreenchange', () => {
      videoContainer.classList.toggle('fullscreen', !!document.fullscreenElement);
      adjustSeekbarPosition();
    });

    try {
      const videoUrl = "@Html.Raw(Model.Item1)";
      const vttUrl = "@Html.Raw(Model.Item2)";
      await player.load(videoUrl);
      console.log('Video loaded successfully!');
      thumbnailTrack = await setupThumbnails(player, thumbElement, vttUrl);
    } catch (error) {
      handleError('Error loading video', error);
    }

    player.addEventListener('error', (event) => {
      handleError('Player error', event.detail);
    });

    seekBar.addEventListener('click', seekToPosition);

    async function setupThumbnails(player, thumbElement, vttUrl) {
      try {
        const thumbnailTrack = await player.addThumbnailsTrack(vttUrl);
        if (!thumbnailTrack) throw new Error('Thumbnail track could not be added.');

        const showThumbnail = debounce(handleThumbnailPreview, 10);
        const hideThumbnail = debounce(hideThumbnailPreview, 20);

        ['mousemove', 'touchmove'].forEach((event) => {
          seekBar.addEventListener(event, (e) => {
            video.removeAttribute('controls');
            video.setAttribute('controls', 'controls');
            isHovering = true; 
            showThumbnail(e);
          });
        });
        ['mouseleave', 'touchend'].forEach((event) => {
          seekBar.addEventListener(event, (e) => {
            isHovering = false; // Update isHovering when interaction ends
            hideThumbnail(e);
          });
        });

        return thumbnailTrack;
      } catch (error) {
        handleError('Failed to set up thumbnails', error);
      }
    }

    function handleThumbnailPreview(event) {
      clearTimeout(hideThumbnailTimer);
      const { offsetX, touchX, position, percent } = getSeekBarInfo(event);
      lastPreviewPosition = position;

      player.getThumbnails(thumbnailTrack.id, position).then((thumbnail) => {
        if (thumbnail?.uris.length) {
          const [imageUrl, { x, y, width, height }] = parseThumbnailData(thumbnail);
          displayThumbnail(thumbElement, imageUrl, x, y, width, height, offsetX, percent);
        }
      }).catch((error) => handleError('Error getting thumbnail', error));
    }

    function hideThumbnailPreview() {
      hideThumbnailTimer = setTimeout(() => {
        thumbElement.style.display = 'none';
        if (!isHovering && video.paused) video.play();
      }, 10);
    }

    function seekToPosition(event) {
      const { position } = getSeekBarInfo(event);
      video.currentTime = position;
      video.pause();
    }

    function adjustSeekbarPosition() {
      document.getElementById('seekbar-container').classList.toggle('fullscreen', !!document.fullscreenElement);
    }

    function debounce(func, delay) {
      let timer;
      return function (...args) {
        clearTimeout(timer);
        timer = setTimeout(() => func.apply(this, args), delay);
      };
    }

    function getSeekBarInfo(event) {
      const seekBarRect = seekBar.getBoundingClientRect();
      const duration = player.seekRange().end;

      let offsetX;
      if (event.type.includes('touch')) {
        offsetX = event.touches[0].clientX - seekBarRect.left;
      } else {
        offsetX = event.pageX - seekBarRect.left;
      }
      const percent = offsetX / seekBarRect.width;
      const position = percent * duration;
      return { offsetX, percent, position };
    }

    function parseThumbnailData(thumbnail) {
      const imageUrl = thumbnail.uris[0].split('#')[0];
      const { x = 0, y = 0, width = 120, height = 68 } = thumbnail;
      return [imageUrl, { x, y, width, height }];
    }

    function displayThumbnail(thumbElement, imageUrl, x, y, width, height, offsetX, percent) {

      thumbElement.style.backgroundImage = `url(${imageUrl})`;
      thumbElement.style.backgroundPosition = `-${x}px -${y}px`;
      thumbElement.style.width = `${width}px`;
      thumbElement.style.height = `${height}px`;
      let thumbX = offsetX;
      thumbX = Math.max(thumbElement.clientWidth / 2, Math.min(seekBarRect.width - thumbElement.clientWidth / 2, thumbX));
      thumbElement.style.left = `${thumbX}px`;
      thumbElement.style.top = `-96px`;
      thumbElement.style.display = 'block';
    }

    function handleError(message, error) {
      console.error(message, error);
      errorDisplay.textContent = `${message}: ${error.message}`;
    }
  });

</script>
